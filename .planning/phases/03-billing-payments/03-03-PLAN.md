---
phase: 03-billing-payments
plan: 03
type: execute
wave: 2
wave_type: SEMI_ASYNC
depends_on: ["03-01"]
files_modified:
  - server/app/services/usage.py
  - server/app/middleware/quota.py
autonomous: true
difficulty: medium
---

<objective>
Implement usage metering and quota enforcement per plan tier.

Purpose: Track API call usage, ingestion counts, storage consumption per organization. Enforce plan limits with 429 responses when exceeded. Free tier gets limited usage.
</objective>

<context>
@server/app/models/billing.py
@server/app/services/stripe_service.py
@server/app/config.py
</context>

<tasks>
<task type="auto">
  <name>Create usage tracking and quota middleware</name>
  <files>
    server/app/services/usage.py
    server/app/middleware/quota.py
  </files>
  <action>
    Usage service (usage.py):
    - PLAN_LIMITS: dict mapping PlanTier → PlanLimits (hard-coded for MVP)
    - get_usage_overview(client, org_id) → UsageOverview
    - increment_usage(client, org_id, category, amount=1)
    - check_quota(client, org_id, category) → bool (True if within limit)
    - reset_usage(client, org_id) — for billing period reset
    - get_usage_metrics(client, org_id) → list[UsageMetric]
    Usage stored in Redis (fast, per-period) with Supabase as backup.

    Quota middleware (quota.py):
    - require_quota(category: str) — FastAPI dependency
    - Checks org usage against plan limits before allowing request
    - Returns 429 Too Many Requests with:
      * X-RateLimit-Limit header
      * X-RateLimit-Remaining header
      * X-RateLimit-Reset header (billing period end)
      * Body: {"detail": "Quota exceeded for {category}", "limit": N, "used": N}
    - Applied to: skill executions, ingestion triggers, storage uploads

    Wire into billing router:
    - GET /billing/usage — Get usage overview
  </action>
  <done>Usage metering service + quota enforcement middleware</done>
</task>
</tasks>

<output>
After completion, create `.planning/phases/03-billing-payments/03-03-SUMMARY.md`
</output>
