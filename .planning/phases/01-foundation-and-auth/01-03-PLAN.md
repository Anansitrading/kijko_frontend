---
phase: 01-foundation-and-auth
plan: 03
type: execute
wave: 3
wave_type: SEQUENTIAL
depends_on: ["01-02"]
files_modified:
  - database/004_rls_policies.sql
  - server/app/services/database.py
  - server/tests/test_rls.py
autonomous: true
difficulty: hard
enhancement_queries:
  - "Supabase RLS policies for multi-tenant SaaS with organization_id and service_role key?"
  - "PostgreSQL RLS SECURITY DEFINER functions for cross-tenant admin operations?"
  - "Testing RLS policies with multiple user contexts in Supabase Python SDK?"
  - "Supabase RLS with external JWT (Keycloak) instead of Supabase Auth — setting auth context?"
  - "Common RLS policy mistakes that leak tenant data in PostgreSQL?"

must_haves:
  truths:
    - "RLS policies active on every table with organization_id column"
    - "User A cannot see or modify User B's data via any query"
    - "Service role can still perform admin operations when needed"
    - "SECURITY DEFINER helpers exist for RLS-safe cross-tenant operations"
  artifacts:
    - path: "database/004_rls_policies.sql"
      provides: "RLS policy definitions for all tables"
      contains: "ENABLE ROW LEVEL SECURITY"
    - path: "server/tests/test_rls.py"
      provides: "Multi-tenant isolation tests"
      contains: "test_tenant_isolation"
  key_links:
    - from: "database/004_rls_policies.sql"
      to: "database/001_project_creation_schema.sql"
      via: "RLS on projects table"
      pattern: "ALTER TABLE projects ENABLE ROW LEVEL SECURITY"
    - from: "server/tests/test_rls.py"
      to: "server/app/services/database.py"
      via: "RLS context setting"
      pattern: "set_rls_context"

user_setup:
  - service: supabase
    why: "RLS requires auth context injection via Supabase RPC or SET LOCAL"
    env_vars:
      - name: SUPABASE_URL
        source: "Supabase Dashboard -> Settings -> API -> Project URL"
      - name: SUPABASE_SERVICE_KEY
        source: "Supabase Dashboard -> Settings -> API -> service_role key"
---

<objective>
Implement Row-Level Security policies on all tables and verify multi-tenant data isolation.

Purpose: RLS is the #1 security control for multi-tenancy. Without it, any query bug leaks tenant data. This plan creates policies, SECURITY DEFINER helpers, and a multi-user test suite to verify isolation.
Output: RLS enabled on all tables, tested with 2+ user contexts, SECURITY DEFINER functions for admin operations.
</objective>

<execution_context>
@/home/devuser/.claude/get-shit-done/workflows/execute-plan.md
@/home/devuser/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/research/PITFALLS.md
@database/001_project_creation_schema.sql
@database/002_skills_tables.sql
@.planning/phases/01-foundation-and-auth/01-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create and deploy RLS policies for all tables</name>
  <files>
    database/004_rls_policies.sql
  </files>
  <action>
    Create comprehensive RLS policies for every table with organization_id or user_id:

    **database/004_rls_policies.sql:**

    1. **Helper function for auth context:**
    ```sql
    -- Get current user's org_id from JWT claims or session setting
    CREATE OR REPLACE FUNCTION auth.current_org_id()
    RETURNS UUID
    LANGUAGE sql STABLE
    AS $$
      SELECT COALESCE(
        current_setting('app.current_org_id', true)::UUID,
        (current_setting('request.jwt.claims', true)::json->>'org_id')::UUID
      )
    $$;

    CREATE OR REPLACE FUNCTION auth.current_user_id()
    RETURNS UUID
    LANGUAGE sql STABLE
    AS $$
      SELECT COALESCE(
        current_setting('app.current_user_id', true)::UUID,
        (current_setting('request.jwt.claims', true)::json->>'sub')::UUID
      )
    $$;
    ```

    2. **Enable RLS on all tables:**
    ```sql
    ALTER TABLE projects ENABLE ROW LEVEL SECURITY;
    ALTER TABLE project_repositories ENABLE ROW LEVEL SECURITY;
    ALTER TABLE project_members ENABLE ROW LEVEL SECURITY;
    ALTER TABLE ingestion_progress ENABLE ROW LEVEL SECURITY;
    ALTER TABLE project_files ENABLE ROW LEVEL SECURITY;
    ALTER TABLE skills ENABLE ROW LEVEL SECURITY;
    ALTER TABLE habits ENABLE ROW LEVEL SECURITY;
    ALTER TABLE reflexes ENABLE ROW LEVEL SECURITY;
    ALTER TABLE skill_executions ENABLE ROW LEVEL SECURITY;
    ```

    3. **Create policies for each table** covering SELECT, INSERT, UPDATE, DELETE:
    - **projects:** `organization_id = auth.current_org_id()` for all operations
    - **project_repositories:** via project's organization_id (join through projects)
    - **project_members:** via project's organization_id
    - **skills:** `user_id = auth.current_user_id()` (skills are user-scoped within org)
    - **habits, reflexes:** via skill's user_id
    - **skill_executions:** via skill's user_id
    - **ingestion_progress, project_files:** via project's organization_id

    4. **SECURITY DEFINER functions:**
    ```sql
    -- Admin function to list all projects (bypasses RLS)
    CREATE OR REPLACE FUNCTION admin_list_projects()
    RETURNS SETOF projects
    LANGUAGE sql SECURITY DEFINER
    AS $$ SELECT * FROM projects $$;
    ```

    5. **Force RLS on table owners** (prevents service_role bypass unless explicitly intended):
    ```sql
    ALTER TABLE projects FORCE ROW LEVEL SECURITY;
    -- Repeat for all tables
    ```

    Deploy via psql or Supabase SQL Editor.

    **CRITICAL:** Test that service_role key bypasses RLS when needed (for admin operations) but regular JWT-authenticated queries respect RLS.
  </action>
  <verify>
    ```bash
    # Verify RLS is enabled on all tables
    python3 -c "
    from server.app.dependencies import get_supabase
    client = get_supabase()
    # This query should work with service_role (bypasses RLS)
    result = client.table('projects').select('id').limit(1).execute()
    print(f'Service role query: {len(result.data)} results (OK - bypasses RLS)')
    "
    ```
  </verify>
  <done>RLS enabled on all tables, policies created for SELECT/INSERT/UPDATE/DELETE, SECURITY DEFINER helpers deployed, auth context functions created</done>
</task>

<task type="auto">
  <name>Task 2: Create multi-tenant RLS isolation tests</name>
  <files>
    server/tests/__init__.py
    server/tests/conftest.py
    server/tests/test_rls.py
  </files>
  <action>
    Create a test suite that verifies tenant data isolation:

    **server/tests/conftest.py:**
    ```python
    import pytest
    from server.app.dependencies import get_supabase

    @pytest.fixture
    def supabase_client():
        return get_supabase()

    @pytest.fixture
    def org_a_context():
        """Context for Organization A"""
        return {"org_id": "00000000-0000-0000-0000-000000000001", "user_id": "00000000-0000-0000-0000-000000000011"}

    @pytest.fixture
    def org_b_context():
        """Context for Organization B"""
        return {"org_id": "00000000-0000-0000-0000-000000000002", "user_id": "00000000-0000-0000-0000-000000000022"}
    ```

    **server/tests/test_rls.py:**
    Test the following scenarios:
    1. **Insert with org A, query with org B → empty result** (tenant isolation)
    2. **Insert with org A, query with org A → returns data** (tenant access works)
    3. **Update across tenants → fails** (can't modify other tenant's data)
    4. **Delete across tenants → fails** (can't delete other tenant's data)
    5. **Service role sees all data** (admin bypass works)

    For each table (projects, skills, habits, reflexes, skill_executions):
    - Create test data with org_a context
    - Verify accessible with org_a context
    - Verify NOT accessible with org_b context
    - Clean up test data

    Use the database service's `set_rls_context()` to switch between org contexts.

    **IMPORTANT:** These tests must use real Supabase (not mocks). Use unique test data identifiers to avoid conflicts with real data. Clean up all test data in teardown.
  </action>
  <verify>
    ```bash
    cd /home/devuser/Kijko-MVP && python -m pytest server/tests/test_rls.py -v
    ```
  </verify>
  <done>RLS isolation tests pass for all tables, verifying that tenant A cannot see/modify tenant B's data, and service role can access all data</done>
</task>

</tasks>

<verification>
1. `SELECT tablename, rowsecurity FROM pg_tables WHERE schemaname = 'public'` — all tables show `rowsecurity = true`
2. RLS isolation tests pass (all assertions in test_rls.py)
3. Service role queries still work (admin operations not blocked)
4. Auth context functions exist (`auth.current_org_id()`, `auth.current_user_id()`)
</verification>

<success_criteria>
- RLS enabled on every table with organization_id or user_id
- Policies cover SELECT, INSERT, UPDATE, DELETE for all tables
- Multi-user test proves tenant A can't access tenant B data
- Service role bypass works for admin operations
- SECURITY DEFINER helper functions deployed
- No RLS policy gaps (verified by comprehensive test suite)
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-and-auth/01-03-SUMMARY.md`
</output>
