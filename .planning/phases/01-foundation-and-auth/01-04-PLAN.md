---
phase: 01-foundation-and-auth
plan: 04
type: execute
wave: 4
wave_type: SEQUENTIAL
depends_on: ["01-03"]
files_modified:
  - server/app/middleware/auth.py
  - server/app/routers/auth.py
  - server/app/services/keycloak.py
  - server/app/models/auth.py
  - server/tests/test_auth.py
autonomous: true
difficulty: hard
enhancement_queries:
  - "FastAPI Keycloak OIDC JWT validation with JWKS discovery endpoint 2026?"
  - "Python python-jose RS256 JWT validation with Keycloak public key rotation?"
  - "FastAPI middleware for setting PostgreSQL RLS context from JWT claims per request?"
  - "Keycloak custom org_id claim mapper configuration for multi-tenant SaaS?"
  - "FastAPI auth endpoints: signup, login, token refresh, logout via Keycloak REST API?"

must_haves:
  truths:
    - "JWT middleware validates Keycloak tokens and rejects expired/invalid tokens"
    - "Auth endpoints (signup, login, refresh, logout) return correct responses"
    - "Middleware sets RLS context (user_id, org_id) per request from JWT claims"
    - "Protected endpoints return 401 without valid Bearer token"
    - "OAuth login via Google and GitHub through Keycloak"
  artifacts:
    - path: "server/app/middleware/auth.py"
      provides: "JWT validation middleware with RLS context injection"
      exports: ["get_current_user", "require_auth"]
    - path: "server/app/routers/auth.py"
      provides: "Auth endpoints: signup, login, refresh, logout, oauth"
      contains: "router = APIRouter"
    - path: "server/app/services/keycloak.py"
      provides: "Keycloak client for user management and token operations"
      exports: ["KeycloakService"]
    - path: "server/app/models/auth.py"
      provides: "Auth request/response models"
      contains: "LoginRequest"
    - path: "server/tests/test_auth.py"
      provides: "Auth middleware and endpoint tests"
      contains: "test_valid_jwt"
  key_links:
    - from: "server/app/middleware/auth.py"
      to: "server/app/services/keycloak.py"
      via: "JWKS key fetch for JWT validation"
      pattern: "jwks|openid-configuration"
    - from: "server/app/middleware/auth.py"
      to: "server/app/services/database.py"
      via: "set_rls_context from JWT claims"
      pattern: "set_rls_context"
    - from: "server/app/routers/auth.py"
      to: "server/app/services/keycloak.py"
      via: "User operations (register, login, token refresh)"
      pattern: "keycloak_service"
    - from: "server/app/main.py"
      to: "server/app/routers/auth.py"
      via: "Router include"
      pattern: "include_router"

user_setup:
  - service: keycloak
    why: "JWT validation and user management"
    env_vars:
      - name: KEYCLOAK_URL
        source: "Keycloak admin console URL (e.g., https://auth.kijko.nl)"
      - name: KEYCLOAK_REALM
        source: "Keycloak realm name (e.g., kijko)"
      - name: KEYCLOAK_CLIENT_ID
        source: "Keycloak client ID for backend"
      - name: KEYCLOAK_CLIENT_SECRET
        source: "Keycloak client secret (confidential client)"
---

<objective>
Implement Keycloak OIDC authentication middleware and auth endpoints for the FastAPI backend.

Purpose: Authentication is the gateway to all protected functionality. Without JWT validation and RLS context injection, no endpoint can serve tenant-scoped data safely.
Output: Working auth middleware, signup/login/refresh/logout endpoints, OAuth support, and JWT-to-RLS context bridge.
</objective>

<execution_context>
@/home/devuser/.claude/get-shit-done/workflows/execute-plan.md
@/home/devuser/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/research/PITFALLS.md
@.planning/research/ARCHITECTURE.md
@.planning/phases/01-foundation-and-auth/01-01-SUMMARY.md
@.planning/phases/01-foundation-and-auth/01-03-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Keycloak service and JWT validation middleware</name>
  <files>
    server/app/services/keycloak.py
    server/app/middleware/auth.py
    server/app/models/auth.py
  </files>
  <action>
    **server/app/services/keycloak.py:**

    Create a KeycloakService class that wraps Keycloak REST API:

    1. **OIDC Discovery:** Fetch `{KEYCLOAK_URL}/realms/{REALM}/.well-known/openid-configuration` on startup. Cache the JWKS endpoint URL and signing keys.

    2. **JWKS key management:**
       - Fetch public keys from JWKS endpoint
       - Cache keys in memory with 1-hour TTL
       - On JWT validation failure, attempt key refresh (handles key rotation)
       - Use `python-jose` with RS256 algorithm

    3. **User operations via Keycloak Admin API:**
       - `register_user(email, password, first_name, last_name)` → POST /admin/realms/{realm}/users
       - `authenticate(email, password)` → POST /realms/{realm}/protocol/openid-connect/token (grant_type=password)
       - `refresh_token(refresh_token)` → POST /realms/{realm}/protocol/openid-connect/token (grant_type=refresh_token)
       - `logout(refresh_token)` → POST /realms/{realm}/protocol/openid-connect/logout
       - `get_oauth_redirect_url(provider)` → builds Keycloak OAuth URL for Google/GitHub

    4. **Token validation:**
       - `validate_token(token: str) -> dict` — decodes JWT, validates signature, expiry, issuer, audience
       - Returns decoded payload with `sub` (user_id), `org_id`, `email`, `roles`
       - Raises HTTPException(401) on invalid/expired token

    **server/app/middleware/auth.py:**

    Create FastAPI dependency for auth:

    ```python
    from fastapi import Depends, HTTPException, Security
    from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials

    security = HTTPBearer()

    async def get_current_user(
        credentials: HTTPAuthorizationCredentials = Security(security),
        keycloak: KeycloakService = Depends(get_keycloak)
    ) -> dict:
        """Validate JWT and return user claims."""
        token = credentials.credentials
        payload = await keycloak.validate_token(token)
        return payload

    async def require_auth(
        user: dict = Depends(get_current_user),
        db: SupabaseClient = Depends(get_supabase)
    ) -> dict:
        """Validate JWT AND set RLS context for database queries."""
        await set_rls_context(db, user["sub"], user["org_id"])
        return user
    ```

    **server/app/models/auth.py:**

    ```python
    class LoginRequest(BaseSchema):
        email: EmailStr
        password: str = Field(min_length=8)

    class SignupRequest(BaseSchema):
        email: EmailStr
        password: str = Field(min_length=8)
        first_name: str = Field(min_length=1, max_length=50)
        last_name: str = Field(min_length=1, max_length=50)

    class TokenResponse(BaseSchema):
        access_token: str
        refresh_token: str
        token_type: str = "Bearer"
        expires_in: int

    class RefreshRequest(BaseSchema):
        refresh_token: str

    class UserProfile(BaseSchema):
        id: UUID
        email: str
        first_name: str
        last_name: str
        org_id: UUID
        roles: list[str]
    ```

    **CRITICAL:** Use OIDC discovery endpoint (not hardcoded JWKS URLs). Cache JWKS but refresh on validation failure.
    **CRITICAL:** Always validate issuer, audience, and expiry claims.
    **CRITICAL:** Use RS256 (asymmetric), not HS256 (symmetric).
  </action>
  <verify>
    ```bash
    python3 -c "
    from server.app.services.keycloak import KeycloakService
    from server.app.middleware.auth import get_current_user, require_auth
    from server.app.models.auth import LoginRequest, TokenResponse
    print('ALL AUTH IMPORTS OK')
    lr = LoginRequest(email='test@example.com', password='testpass123')
    print(f'LoginRequest validation: {lr.email}')
    "
    ```
  </verify>
  <done>KeycloakService created with OIDC discovery, JWKS caching, user operations. Auth middleware provides get_current_user and require_auth dependencies. Auth models defined.</done>
</task>

<task type="auto">
  <name>Task 2: Create auth router and wire into main app</name>
  <files>
    server/app/routers/auth.py
    server/app/main.py
    server/tests/test_auth.py
  </files>
  <action>
    **server/app/routers/auth.py:**

    Create auth router with these endpoints:

    1. `POST /api/v1/auth/signup` — Register new user
       - Request: SignupRequest (email, password, first_name, last_name)
       - Creates user in Keycloak
       - Returns TokenResponse (auto-login after signup)
       - 409 if email already exists

    2. `POST /api/v1/auth/login` — Login
       - Request: LoginRequest (email, password)
       - Authenticates via Keycloak token endpoint
       - Returns TokenResponse (access_token, refresh_token, expires_in)
       - 401 if invalid credentials

    3. `POST /api/v1/auth/refresh` — Refresh token
       - Request: RefreshRequest (refresh_token)
       - Returns new TokenResponse
       - 401 if refresh token expired/invalid

    4. `POST /api/v1/auth/logout` — Logout
       - Request: RefreshRequest (refresh_token)
       - Invalidates refresh token in Keycloak
       - Returns 204 No Content

    5. `GET /api/v1/auth/me` — Get current user profile (protected)
       - Requires: Bearer token
       - Returns: UserProfile from JWT claims
       - 401 if not authenticated

    6. `GET /api/v1/auth/oauth/{provider}` — OAuth redirect URL
       - provider: "google" | "github"
       - Returns: {"redirect_url": "https://auth.kijko.nl/realms/kijko/protocol/openid-connect/auth?..."}

    7. `POST /api/v1/auth/oauth/callback` — OAuth callback
       - Receives authorization code
       - Exchanges for tokens via Keycloak
       - Returns TokenResponse

    **Update server/app/main.py:**
    - Include auth router: `app.include_router(auth_router, prefix=settings.API_PREFIX)`
    - Exclude auth endpoints from global auth middleware (they are public)

    **server/tests/test_auth.py:**
    Create tests using FastAPI TestClient:

    1. `test_signup_returns_tokens` — POST /auth/signup with valid data → 201 with tokens
    2. `test_signup_duplicate_email` — POST /auth/signup with existing email → 409
    3. `test_login_valid_credentials` — POST /auth/login → 200 with tokens
    4. `test_login_invalid_credentials` — POST /auth/login with wrong password → 401
    5. `test_refresh_valid_token` — POST /auth/refresh → 200 with new tokens
    6. `test_refresh_invalid_token` — POST /auth/refresh with bad token → 401
    7. `test_me_authenticated` — GET /auth/me with valid Bearer → 200 with profile
    8. `test_me_unauthenticated` — GET /auth/me without token → 401
    9. `test_protected_endpoint_without_token` — Any protected endpoint → 401

    For tests that need Keycloak, use httpx mock responses or create test fixtures with known JWT tokens signed with a test RSA key.
  </action>
  <verify>
    ```bash
    # Verify router is wired up
    python3 -c "
    from server.app.main import app
    routes = [r.path for r in app.routes]
    assert '/api/v1/auth/login' in routes or any('auth' in str(r.path) for r in app.routes), f'Auth routes not found in {routes}'
    print('Auth router wired up')
    "

    # Run auth tests
    cd /home/devuser/Kijko-MVP && python -m pytest server/tests/test_auth.py -v
    ```
  </verify>
  <done>Auth router with 7 endpoints wired into main app. Tests verify signup, login, refresh, logout, me, and OAuth flows. Protected endpoints return 401 without valid token.</done>
</task>

</tasks>

<verification>
1. `POST /api/v1/auth/login` with valid credentials → 200 with access_token and refresh_token
2. `POST /api/v1/auth/login` with invalid credentials → 401
3. `GET /api/v1/auth/me` with valid Bearer token → 200 with user profile including org_id
4. `GET /api/v1/auth/me` without token → 401
5. Any protected endpoint without token → 401
6. JWT validation uses RS256 and OIDC discovery (not hardcoded keys)
7. Auth tests pass: `pytest server/tests/test_auth.py -v`
</verification>

<success_criteria>
- All 7 auth endpoints respond correctly
- JWT validation uses OIDC discovery + JWKS caching + RS256
- Auth middleware injects RLS context (user_id, org_id) per request
- Invalid/expired tokens return 401 (not 500)
- Auth tests pass with mocked Keycloak responses
- Google and GitHub OAuth redirect URLs are generated correctly
- Token refresh works and returns new access + refresh tokens
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-and-auth/01-04-SUMMARY.md`
</output>
